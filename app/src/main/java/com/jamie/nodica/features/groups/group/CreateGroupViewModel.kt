// main/java/com/jamie/nodica/features/groups/group/CreateGroupViewModel.kt
package com.jamie.nodica.features.groups.group

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.jamie.nodica.features.profile.TagItem // Import if needed, maybe not
import io.github.jan.supabase.SupabaseClient
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.launch
import timber.log.Timber

class CreateGroupViewModel(
    private val groupUseCase: GroupUseCase,
    private val currentUserId: String,
    supabaseClient: SupabaseClient
) : ViewModel() {

    private val _creationState = MutableStateFlow<CreateGroupUiState>(CreateGroupUiState.Idle)
    val creationState: StateFlow<CreateGroupUiState> get() = _creationState.asStateFlow()

    // Need to fetch available tags similar to ProfileViewModel if using chips
    private val _availableTags = MutableStateFlow<Map<String, List<TagItem>>>(emptyMap())
    val availableTags: StateFlow<Map<String, List<TagItem>>> get() = _availableTags.asStateFlow()

    init {
        // TODO: Fetch available tags from a shared repository/use case if needed for selection UI
        // fetchAvailableTags()
        Timber.d("CreateGroupViewModel initialized for user $currentUserId")
    }

    // TODO: Implement fetchAvailableTags if using dynamic chip selection
    // private fun fetchAvailableTags() { ... }


    fun createGroup(
        name: String,
        description: String,
        meetingSchedule: String,
        selectedTagIds: List<String> // Accept Tag IDs from UI
    ) {
        _creationState.value = CreateGroupUiState.Loading
        Timber.d("Attempting to create group. Name: $name, Tags: $selectedTagIds")
        viewModelScope.launch {
            // Build the basic group object. ID is generated by DB.
            // The 'tags' field in Group object isn't directly saved; pass tagIds separately.
            val newGroup = Group(
                id = "", // Let Supabase generate the id
                name = name.trim(),
                description = description.trim(),
                meetingSchedule = meetingSchedule.trim().ifBlank { null },
                creatorId = currentUserId,
                tags = emptyList() // This list isn't used directly in insert, pass IDs below
                // member count is handled by repository/DB trigger
            )

            // Call the use case with the Group object and the selected Tag IDs
            groupUseCase.createGroup(newGroup, selectedTagIds).fold(
                onSuccess = { createdGroup ->
                    Timber.i("Group created successfully: ${createdGroup.id}")
                    _creationState.value = CreateGroupUiState.Success(createdGroup)
                },
                onFailure = { error ->
                    Timber.e(error, "Failed to create group")
                    _creationState.value = CreateGroupUiState.Error(error.message ?: "Error creating group")
                }
            )
        }
    }

    fun resetState() {
        _creationState.value = CreateGroupUiState.Idle
    }
}

sealed class CreateGroupUiState {
    object Idle : CreateGroupUiState()
    object Loading : CreateGroupUiState()
    data class Success(val group: Group) : CreateGroupUiState()
    data class Error(val message: String) : CreateGroupUiState()
}